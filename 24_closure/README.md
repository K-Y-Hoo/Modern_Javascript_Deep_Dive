# 24_클로저

```jsx
const x = 1;

function outerFunc() {
	const x = 10;
	innerFunc();
}

function innerFunc() {
	console.log(x);        // 1
}                        //innerFunc가 어디서 호출되었는지는 중요하지 않다.
                         //함수를 어디에 정의했는지에 따라 상위 스코프가 결정된다.
                         //렉시컬 스코프(정적 스코프)
outerFunc();
```

```jsx
const x = 1;

function foo() {
	const x = 10;
	bar();
}

function bar() {
	console.log(x);
}

foo();    // 1
bar();    // 1
```

렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값(상위 스코프에 대한 참조)은 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. → 렉시컬 스코프

### 함수 객체의 내부 슬롯 [[Environment]]

`[[Environment]]에 상위 스코프의 참조를 저장`

`자신이 호출되었을 때 생성될 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장될 참조값`

### 클로저와 렉시컬 환경

`외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.`

`중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되어야만 클로저다.`

- 외부 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다. (내부 중첩 함수에 의해 외부 함수가 참조되고 있다면 가비지 컬렉션의 대상이 되지 않는다.)
- 내부 중첩함수가 외부 함수보다 더 오래 유지되지만 상위 스코프(외부 함수)의 어떤 식별자도 참조하지 않는 경우는 클로저가 아니다.
- 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수라 한다.

### 클로저의 활용

- 상태를 안전하게 변경하고 유지하기 위해 사용됨
- 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용됨

```jsx
const increase = (function () {
	let num = 0;
	return function () {
		return ++num;
	};
}());
console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

- 부수 효과를 억제하여 오류를 피하고 안정성을 높이기 위해 적극적으로 사용됨

### 캡슐화, 정보 은닉

- 캡슐화: 객체의 프로퍼티와 메서드를 하나로 묶는 것
- 정보 은닉: 객체의 특정 프로퍼티나 메서드를 감출 목적 → 객체 간 결합도를 낮추는 효과