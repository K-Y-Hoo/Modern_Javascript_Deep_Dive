# 25_클래스

`클래스는 생성자 함수보다 엄격하며 생성자 함수에서 제공하지 않는 기능도 제공한다.`

- 클래스는 new 연산자 없이 호출하면 에러 발생, 생성자 함수는 new 연산자 없이 호출하면 일반 함수로서 호출됨
- 클래스는 상속을 지원하는 extends, super 키워드 제공
- 클래스는 호이스팅이 발생하지 않는 것처럼 동작
- 클래스 내의 모든 코드는 암묵적으로 strict mode 적용됨, 해제 불가능
- 클래스는 열거되지 않는다.

### 클래스 정의

```jsx
//클래스 선언문(파스칼 케이스)
class Person {}

//익명 클래스 표현식
const Person = class {};

//기명 클래스 표현식
const Person = class MyClass {};
```

클래스를 표현식으로 정의할 수 있다 → 일급 객체

- 무명의 리터럴로 생성 가능(런타임에 생성 가능)
- 변수나 자료구조(객체, 배열)에 저장 가능
- 함수의 매개변수에 전달 가능
- 함수의 반환값으로 사용 가능

### 클래스 호이스팅

- 클래스는 클래스 정의 이전에 참조할 수 없다.
- 호이스팅이 발생하지 않는 것처럼 보이나 실제로는 호이스팅이 발생한다. (TDZ때문)

### 인스턴스 생성

`클래스는 생성자 함수 → new 연산자와 함께 호출되어 인스턴스를 생성`

### 메서드

- constructor(생성자): 클래스 내에 최대 한 개만 존재 가능, 생략할 시 클래스에 빈 constructor가 암묵적으로 정의됨, constructor 내부에선 return문을 반드시 생략해야 함.
- 프로토타입 메서드: 인스턴스로 호출됨
- 정적 메서드: 클래스로 호출됨 → 인스턴스로 클래스의 메서드를 상속받을 수 없다.
- 클래스에서 정의한 메서드의 특징
    - function 키워드를 생략한 메서드 축약 표현 사용
    - 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없음
    - 암묵적 strict mode 실행
    - for … in 문 혹은 Object.keys 메서드 등으로 열거 불가능
    - non-constructor. new 연산자와 함께 호출 불가능

### 클래스의 인스턴스 생성 과정

- 인스턴스 생성과 this 바인딩
- 인스턴스 초기화
- 인스턴스 반환

### 프로퍼티

- 인스턴스 프로퍼티
- 접근자 프로퍼티
- 클래스 필드: 클래스가 생성할 인스턴스의 프로퍼티(this 없이 메서드만 선언 가능)
- private 필드: 선두에 #을 붙인다. 참조할 때도 #을 붙인다.
- static 필드

### 상속에 의한 클래스 확장

`기존 클래스를 상속받아 새로운 클래스를 확장하여 정의` `extends`

Rest 파라미터: 매개변수에 …을 붙인다. 함수에 전달된 인수들의 목록을 배열로 전달받는다.

super 키워드: this와 같이 식별자처럼 참조할 수 있는 특수한 키워드

- super를 호출하면 수퍼클래스의 constructor를 호출
- super를 참조하면 수퍼클래스의 메서드를 호출 가능
- 서브클래스에서 constructor를 생략하지 않은 경우 서브클래스의 constructor에서 반드시 super를 호출해야 한다. 호출하지 않으면 this를 참조할 수 없다.
- 서브클래스는 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다.