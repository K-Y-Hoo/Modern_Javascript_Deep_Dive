# 47_에러 처리

## 에러 처리의 필요성

- 에러가 발생하지 않는 코드를 작성하는 것은 불가능하다. 에러는 언제나 발생할 수 있으므로 발생한 에러에 대해 대처하지 않고 방치하면 프로그램은 강제 종료된다.
- try … catch 문을 사용해 발생한 에러에 적절하게 대응하면 프로그램이 강제 종료되지 않고 계속해서 코드를 실행시킬 수 있다.
- 에러 처리 방법은 크게 두 가지로, querySelector나 Array#find 메서드처럼 예외적인 상황이 발생하면 반환하는 값(null 또는 -1)을 if 문이나 단축 평가 또는 옵셔널 체이닝 연산자를 통해 확인해서 처리하는 방법, 에러 처리 코드를 미리 등록해 두고 에러가 발생하면 에러 처리 코드로 점프하도록 하는 방법이 있다.(try…catch…finally)
- 언제나 에러나 예외적인 상황이 발생할 수 있다는 것을 전제하고 이에 대응하는 코드를 작성하는 것이 중요하다.

## try.. catch… finally 문

```jsx
try {
	// 실행할 코드(에러가 발생할 가능성이 있는 코드)
} catch (err) {
	// try 코드 블록에서 에러가 발생하면 이 코드 블록의 코드가 실행된다.
	// err에는 try 코드 블록에서 발생한 Error 객체가 전달된다.
} finally {
	// 에러 발생과 상관없이 반드시 한 번 실행된다.
}

//try… catch… finally 문으로 에러를 처리하면 프로그램이 강제 종료되지 않는다.
console.log('[end]'); // [end]

```

## Error 객체

`Error 생성자 함수는 에러 객체를 생성, Error 생성자 함수에는 에러를 상세히 설명하는 에러 메시지를 인수로 전달할 수 있다.`

```jsx
const error = new Error('메시지');
```

Error 생성자 함수

- Error
- SyntaxError
- ReferenceError
- TypeError
- RangeError
- URIError
- EvalError

## throw 문

`Error 생성자 함수로 에러 객체를 생성한다고 에러가 발생하는 것이 아니다. 에러 객체 생성과 에러 발생은 다르다.`

`에러를 발생시키려면 try 코드 블록에서 throw 문으로 에러 객체를 던져야 한다.`

```jsx
throw 표현식;
// 일반적으로 throw 문의 표현식은 에러 객체를 지정한다. 
// 에러를 던지면 catch 문의 에러 변수가 생성되고 던져진 에러 객체가 할당된다.
// 그리고 catch 코드 블록이 실행되기 시작한다.
```

```jsx
try {
	throw new Error('something wrong');
} catch (error) {
	console.log(error);
}
```

## 에러의 전파

`에러는 호출자 방향으로 전파된다. 콜 스택의 아래 방향(실행 중인 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향)으로 전파된다.`

- throw 된 에러를 캐치하지 않으면 호출자 방향으로 전파된다.
- throw 된 에러를 캐치하여 적절히 대응하면 프로그램을 강제 종료시키지 않고 코드의 실행 흐름을 복구할 수 있다.
- throw된 에러를 어디에서도 캐치하지 않으면 프로그램은 강제 종료된다.
- 비동기 함수인 setTimeout이나 프로미스 후속 처리 메서드의 콜백 함수는 호출자가 없어서 에러를 전파할 호출자가 존재하지 않는다.